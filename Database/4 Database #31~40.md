# 4. Database #31~40

**#31_내장 SQL의 특징**

- 내장 SQL : 응용 프로그램 내에 SQL 문장을 내포하여 프로그램이 실행될 때 함께 실행되도록 호스트 프로그램 언어에 삽입된 SQL

- 일반 SQL 실행문은 호스트 언어에서 실행문이 나타날 수 있는 곳이면 프로그램의 어느 곳에서나 사용 가능

- 일반 SQL문은 수행 결과로 여러 개의 튜플을 반환하는 반면, 내장 SQL은 단 하나의 튜플만을 반환

- 내장 SQL문에 의해 반환되는 튜플은 일반 변수를 사용하여 저장할 수 있음

- 호스트 프로그램의 컴파일 시 선행처리기에 의해 내장 SQL문은 분리되어 컴파일됨

- 호스트 변수와 데이터베이스 필드의 이름은 같아도 됨

- 내장 SQL문의 호스트 변수의 데이터 타입은 이에 대응하는 데이터베이스 필드의 SQL 데이터 타입과 일치하여야 함

- 삽입 SQL문이 실행되면 SQL 실행의 상태가 SQL 상태 변수에 전달됨

- 호스트 언어의 실행문과 구분시키는 방법

① 명령문의 구분

ㆍC/C++에서 내장 SQL문은 $와 세미콜론(;) 문자 사이에 기술함

ㆍVisual BASIC에서는 내장 SQL문 앞에 'EXEC SQL'을 기술함

② 변수의 구분

ㆍ내장 SQL에서 사용하는 호스트 변수는 변수 앞에 콜론(:) 문자를 붙임

**#32_시스템 카탈로그**

- 시스템 그 자체에 관련이 있는 다양한 객체에 관한 정보를 포함하는 시스템 데이터베이스

- 데이터베이스에 포함되는 모든 데이터 객체에 대한 정의나 명세에 관한 정보를 유지 관리하는 시스템 테이블

- 데이터 정의어(DDL)의 결과로 구성되는 기본 테이블, 뷰, 인덱스, 패키지, 접근권한 등의 데이터베이스 구조 및 통계 정보를 저장

- 카탈로그들이 생성되면 자료 사전(Data Dictionary)에 저장되기 때문에 좁은 의미로는 카탈로그를 **자료사전** 이라고도함

- 카탈로그에 저장된 정보를 메타 데이터(Meta-Data)라고 함

- 카탈로그의 특징

ㆍ카탈로그 자체도 시스템 테이블로 구성되어 있어 일반 이용자도 SQL을 이용하여 내용을 검색해 볼 수 있음

ㆍINSERT, DELETE, UPDATE문으로 갱신하는 것은 허용하지 않음

ㆍDBMS가 스스로 생성하고 유지함

ㆍ카탈로그는 사용자가 SQL문을 실행시켜 기본 테이블, 뷰, 인덱스 등에 변화를 주면 시스템이 자동으로 갱신함

**#33_뷰(View)**

- **사용자에게 접근이 허용된 자료만을 제한적으로 보여주기 위해 하나 이상의 기본 테이블로부터 유도된, 이름을 가지는 가상 테이블**

- 권한이 있는 상태로 **저장장치 내에 물리적으로 존재하지 않지만,** 사용자에게는 있는 것처럼 간주됨

- 뷰(View)의 특징

ㆍ기본 테이블로부터 유도된 테이블이기 때문에 기본 테이블과 같은 형태의 구조를 가지며, 조작도 기본 테이블과 거의 같음

ㆍ가상 테이블이기 때문에 물리적으로 구현되어 있지 않음

ㆍ필요한 데이터만 뷰로 정의해서 처리할 수 있기 때문에 관리가 용이하고 명령문이 간단해짐

ㆍ뷰를 통해서만 데이터에 접근하게 하면 **뷰에 나타나지 않는 데이터를 안전하게 보호하는 효율적인 기법으로 사용할 수 있음**

ㆍ기본 테이블의 기본키를 포함한 속성(열) 집합으로 뷰를 구성해야만 삽입, 삭제, 갱신 연산이 가능

ㆍ정의된 뷰는 다른 뷰의 정의에 기초가 될 수 있음

ㆍ하나의 뷰를 삭제하면 그 뷰를 기초로 정의된 다른 뷰도 자동으로 삭제됨

- 뷰의 장점

ㆍ논리적 데이터 독립성을 제공

ㆍ동일 데이터에 대해 동시에 여러 사용자의 상이한 응용이나 요구를 지원

ㆍ사용자의 데이터 관리를 간단하게 해줌

ㆍ접근제어를 통합 자동 보안이 제공

- 뷰의 단점

ㆍ독립적인 인덱스를 가질 수 없음

ㆍ뷰의 정의를 변경할 수 없음

ㆍ뷰로 구성된 내용에 대한 삽입, 삭제, 갱신 연산에 제약이 따름

**#34_자료구조의 분류**

- 선형구조 : 선형리스트, 연결리스트, 스택, 큐, 데크

- 비선형 구조 : 트리, 그래프

**#35_Stack(스택) ; 선형구조**

- 리스트의 한쪽 끝으로만 자료의 삽입, 삭제 작업이 이루어지는 자료구조

- **가장 나중에 삽입된 자료가 가장 먼저 삭제되는 후입선출(LIFO, Last-In, First-Out) 방식**으로 자료를 처리

- TOP(스택 포인터) : Stack으로 할당된 기억공간에 가장 마지막으로 삽입된 자료가 기억된 공간을 가리키는 요소, 스택 포인터 라고도 함

- Bottom : 스택의 가장 밑바닥

- Stack의 용도

ㆍ부프로그램 호출 시 복귀주소를 저장할 때

ㆍ인터럽트가 발생하여 복귀주소를 저장할 때

ㆍ후위표기법(Postfix Notation)으로 표현된 산술식을 연산할 때

ㆍ0 주소 지정방식 명령어의 자료저장소

ㆍ재귀(RECURSIVE) 프로그램의 순서제어

ㆍ컴파일러를 이용한 언어변역 시

**#36_큐(Queue) ; 선형구조**

- 선형 리스트의 **한쪽에서는 삽입작업이** 이루어지고 **다른 쪽에서는 삭제 작업이** 이루어지도록 구성한 자료구조

- **가장 먼저 삽입된 자료가 가장 먼저 삭제되는 선입선출(FIFO ; First-In. First-Out)** 방식으로 처리

- Queue를 이용하는 예

ㆍ창구업무처럼 서비스 순서를 기다리는 등의 대기행렬의 처리에 사용

ㆍ운영체제의 작업 스케줄링에 사용

**#37_데크(Deque) ; 선형구조**

- 삽입과 삭제가 리스트의 양쪽 끝에서 모두 발생할 수 있는 자료구조

- 스택과 큐의 장점만 따서 구성한 것임

- 입력이 한쪽에서만 발생하고 출력은 양쪽에서 일어날 수 이쓴 입력제한과, 입력은 양쪽에서 일어나고 출력은 한곳에서만 이루어지는 출력 제한이 있음

- 입력 제한 데크 : Scroll

- 출력 제한 데크 : Shelf

**#38_트리(Tree) 관련용어**

![https://blog.kakaocdn.net/dn/bynTaf/btqDurMvj4R/cSe63JVKAODHpuTwXWAYV1/img.png](https://blog.kakaocdn.net/dn/bynTaf/btqDurMvj4R/cSe63JVKAODHpuTwXWAYV1/img.png)

- 노드(Node) : 하나의 자료항목과 다른 항목에 대한 가지(Branch)를 합친 것

ex) A, B, C, D, E, F, G, H, I, J, K, L, M

- 근노드(Root Node) : 트리의 맨 위에 있는 노드 ex) A

- 디그리(Degree, 차수) : 각 노드에서 뻗어 나온 가지의 수 ex) A=3, B=2, C=1, D=3

- 트리의 디그리 : 노드들의 디그리 중에서 가장 많은 수

ex) 노드 A나 D가 3개의 디그리를 가지므로 위 트리의 디그리는 3임

- 단말노드(Terminal Node)=잎노드(Leaf Node) : 자식이 하나도 없는 노드 즉 Degree가 0인 노드

ex) K, L, F, G, M, I, J

- 비단말 노드(Non-Terminal Node) : 자식이 하나라도 있는 노드 즉, Degree가 0이 아닌 노드

ex) A, B, C, D, E, H

- 자노드(Son Node) : 어떤 노드에 연결된 다음 레벨의 노드들

ex) D의 자노드 : H, I, J

- 부노드(Parent Node) : 어떤 노드에 연결된 이전 레벨의 노드들

ex) E, F 의 부노드는 B

- 형제노드(Brother Node, Sibling) : 동일한 부모를 갖는 노드들

ex) H의 형제노드는 I, J

- Level : 근노드의 Level을 1로 가정한 후 어떤 Level이 L이면 자식노드는 L+1

ex) H의 레벨은 3

- 깊이(Depth, Height) : 어떤 Tree에서 노드가 가질 수 있는 최대의 레벨

ex) 위 트리의 깊이는 4

**#39_이진트리의 운행법(Traversal)**

![https://blog.kakaocdn.net/dn/3vJmX/btqDvgRuVvB/ZcQDFC22lubKwkVQ4nnhUk/img.png](https://blog.kakaocdn.net/dn/3vJmX/btqDvgRuVvB/ZcQDFC22lubKwkVQ4nnhUk/img.png)

- Preorder 운행 : Root -> Left -> Right 순으로 운행함

- Inorder 운행 : Left -> Root -> Right 순으로 운행함

- Postorder 운행 : Left -> Right -> Root 순으로 운행함

**#40_수식의 표기법**

![https://blog.kakaocdn.net/dn/cqkAe8/btqDp1BK8NC/6RZI8voS6S1cOtjGijU6j0/img.png](https://blog.kakaocdn.net/dn/cqkAe8/btqDp1BK8NC/6RZI8voS6S1cOtjGijU6j0/img.png)

- 전위표기법(PreFix) : 연산자 -> Left -> Right

- 중위표기법(InFix) : Left -> 연산자 -> Right

- 후위표기법(PostFix) : Left -> Right -> 연산자