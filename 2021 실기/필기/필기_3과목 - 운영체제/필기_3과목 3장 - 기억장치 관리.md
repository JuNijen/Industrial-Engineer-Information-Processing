# #082. 기억장치 관리의 개요
주기억장치, 보조기억장치, 캐시 기억장치, 가상기억장치 등을 통틀어 일컫는 말.

## 1. 기억장치 계층 구조의 특징
기억장치는 레지스터, 캐시 기억장치, 주기억장치, 보조기억장치를 계층 구조로 분류할 수 있다.
- 계층 구조에서 상위의 기억장치일수록 접근 속도가 증가되어 접근 시간이 빠르지만, 기억 용량이 적고 고가이다.
- 주기억장치는 각기 자신의 주소를 갖는 워드 또는 바이트들로 구성되어 있으며, 주소를 이용하여 액세스 할 수 있다.
- 레지스터, 캐시 기억장치, 주기억장치의 프로그램과 데이터는 CPU가 직접 액세스 할 수 있으나 보조기억장치에 있는 프로그램이나 데이터는 직접 액세스할 수 없다.
- 보조기억장치에 있는 데이터는 주기억장치에 적재된 후 CPU에 의해 액세스될 수 있다.

## 2. 기억장치의 관리 전략
보조기억장치의 프로그램이나 데이터를 주기억장치에 적재시키는 시기, 적재 위치 등을 지정하여 한정된 주기억장치의 공간을 효율적으로 사용하기 위한 것이다.
### 반입(Fetch) 전략
보조기억장치에 보관중인 프로그램이나 데이터를 언제 주기억장치로 적재할 것인지를 결정하는 전략.
- 요구 반입(Demand Fetch) : 실행중인 프로그램이 특정 프로그램이나 데이터 등의 참조 요구할 때 적재하는 방법.
- 예상 반입(Anticipatory Fetch) : 실행중인 프로그램에 의해 참조될 프로그램이나 데이터를 미리 예상하여 적재하는 방법.
### 배치(Placement) 전략
프로그램이나 데이터가 들어갈 수 있는 크기의 빈 영역 중에서
- 최초 적합(Fist Fit) : 첫 번째 분할 영역에 배치시키는 방법.
- **최적 적합(Best Fit)** : 단편화를 가장 작게 남기는 분할 영역에 배치시키는 방법.
- 최악 접합(Worst Fit) : 단편화를 가장 많이 남기는 분할 영역에 배치시키는 방법.
* 단편화 - 주기억장치의 분할된 영역에 프로그램이나 데이터를 할당할 경우, **분할된 영역이 프로그램이나 데이터보다 작거나 커서 생기는 빈 기억공간.**
### 교체(Replacement) 전략
주기억장치의 모든 영역이 이미 사용중인 상태에서 새로운 프로그램이나 데이터를 주기억장치에 배치하려고 할 때, 이미 **사용되고 있는 영역 중에서 어느 영역을 교체하여 사용할 것인지를 결정**하는 전략.
- 교체 전략에는 FIFO, OPT, LRU, LFU, NUR, SCR 등이 있다.


# #083. 주기억장치 할당 기법
## 1.
## 2.
## 3.


# #084. 주기억장치 관리 기법의 문제점과 해결 방법
## 1.
## 2.
## 3.


# #085. 가상기억장치 구현 기법

## 1. 가상기억장치

## 2. 페이징(Paging) 기법
가상기억장치에 보관되어 있는 프로그램과 주기억장치의 영역을 동일한 크기로 나눈 후 나눠진 프로그램(페이지)을 동일하게 나눠진 주기억장치의 영역(페이지 프레임)에 적재시켜 실행하는 기법이다.
- **프로그램을 일정한 크기로 나눈 단위**를 ``페이지(Page)``라고 하고, **페이지 크기로 일정하게 나누어진 주기억장치의 단위**를 ``페이지 프레임(Page Frame)``이라고 한다.
- 외부 단편화는 발생하지 않으나 내부 단편화는 발생할 수 있다.
- 주소 변환을 위해서 **페이지의 위치 정보를 가지고 있는 ``페이지 맵 테이블(Page Map Table)``이 필요**하다.
- 페이지 맵 테이블 사용으로 비용이 증가되고, 처리 속도가 감소한다.

## 3. 세그먼테이션(Segmentation) 기법
가장기억장치에 보관되어 있는 프로그램을 다양한 크기의 논리적인 단위로 나눈 후 주기억장치에 적재시켜 실행시키는 기법.
- **프로그램을 배열이나 함수 등과 같은 논리적인 크기로 나눈 단위**를 ``세그먼트``라고 하며, 각 세그먼트는 고유한 이름과 크기를 갖는다.
- **기억장치의 사용자 관점을 보존**하는 기억장치 관리 기법이다.
- 세그먼테이션 기법을 이용하는 궁극적인 이유는 **기억공간을 절약**하기 위해서이다.
- 주소 변환을 위해서 **세그먼트가 존재하는 위치 정보를 가지고 있는 세그먼트 맵 테이블(Segment Map Table)이 필요**하다.
- 세그먼트가 주기억장치에 적재될 때 다른 세그먼트에게 할당된 영역을 침범할 수 없으며, 이를 위해 **기억장치 보호키(Storage Protection Key)가 필요**하다.


# #086. 페이지 교체 알고리즘
``페이지 부재(Page Fault)``가 발생했을 때 가상기억장치의 필요한 페이지를 주기억장치에 적재해야 하는데, 이때 주기억장치의 모든 페이지 프레임이 사용 중이면 어떤 페이지 프레임을 선택하여 교체할 것인지를 결정하는 기법이다.

## 1. OTP(OPTimal replacement, 최적 교체)
**앞으로 가장 오랫동안 사용하지 않을 페이지를 교체하는 기법.**
- 벨레이디(Belady)가 제안한 것으로, 페이지 부재 횟수가 가장 적게 발생하는 **가장 효율적인 알고리즘**이다.
- 각 페이지의 호출 순서와 참조 상황을 미리 예측해야 하므로 **실현 가능성이 희박*하다.

## 2. ★ FIFO(First In First Out)
각 페이지가 주기억장치에 적재될 때마다 그때의 시간을 기억시켜 가장 먼저 들어와서 **가장 오래 있었던 페이지를 교체**하는 기법이다.
- 이해하기 쉽고, 프로그래밍 및 설계가 간단하다.
- 벨레이디의 모순(Belady's Anomaly)현상이 발생한다.
* 벨레이디의 모순 현상 : 페이지 프레임 수가 많으면 페이지 부재의 수가 줄어드는 것이 일반적이지만, 페이지 프레임 수를 증가시켯음에도 불구하고 페이지 부재가 더 많이 일어나는 현상을 의미합니다.

## 3. ★LRU(Least Recently Used)
**가장 오랫동안 사용하지 않은 페이지를 교체**하는 기법.
- 각 페이지마다 계수기(Counter)나 스택(Stack)을 두어 현 시점에서 가장 오랫동안 사용하지 않은, 즉 가장 오래 전에 사용된 페이지를 교체한다.
- 계수기나 스택과 같은 **별도의 하드웨어가 필요**하며, 시간적인 오버헤드가 발생한다.
- **실제로 구현하기가 매우 어렵다.**

### LRU 근사 알고리즘
실제 구현이 어렵기 때문에 시스템에서는 LRU와 비슷한 알고리즘을 사용하게 되며,, 이를 칭한다. 참조비트를 사용하는 것으로, NUR 등이 있다.

## 4. LFU(Least Frequently Used)
사용 빈도가 가장 적은 페이지를 교체하는 기법.
- 활발하게 사용되는 페이지는 사용 횟수가 많아 교체되지 않고 사용된다.
- 프로그램 실행 초기에 많이 사용된 페이지가 그 후로 사용되지 않을 경우에도 프레임을 계속 차지할 수 있다.

## 5. ☆ NUR(Not Used Recently)
LRU와 비슷한 알고리즘으로, 최근에 사용하지 않은 페이지를 교체하는 기법.
- **최근에 사용되지 않은 페이지는 향후에도 사용되지 않을 가능성이 높다는 것을 전제**로, LRU에서 나타나는 시간적인 오버헤드를 줄일 수 있다.
최근의 사용 여부를 확인하기 위해서 각 페이지마다 두 개의 비트, 즉 ``참조 비트(Reference Bit)``와 ``변형 비트(Modified Bit, Dirty Bit)``가 사용된다.
- 참조 비트 : 페이지가 호출되지 않았을 때는 0, 호출되었을 때는 1로 지정된다.
- 변형 비트 : 페이지 내용이 변경되지 않았을 때는 0, 변경되었을 때는 1로 지정된다.

## 6. SCR(Second Chance Replacementm 2차 기회 교체)
가장 오랫동안 주기억장치에 있던 페이지 중 자주 사용되는 페이지의 교체를 방지하기 위한 것. FIFO 기법의 단점을 보완하는 기법이다.
- 각 페이지마다 참조 비트를 두고, FIFO 기법을 이용하여 페이지 교체 수행 중 참조 비트가 0일 경우에는 교체하고, 참조 비트가 1일 경우에는 참조 비트를 0으로 지정한 후 FIFO 리스트의 맨 마지막으로 피드백시켜 다음 순서를 기다리게 한다.
- 교체 대상이 되기 전에 참조 비트를 검사하여 1일 경우 한 번의 기회를 더 부여하기 때문에 'Second Chance'라고도 한다.


# #087. 가상기억장치 기타 관리 사항

## 1. 페이지 크기
### 페이지 크기가 작을 경우
- 페이지 단편화가 감소되고, 한 개의 페이지를 주기억장치로 이동하는 시간이 줄어든다.
- 프로세스(프로그램) 수행에 필요한 내용만 주기억장치에 적재할 수 있고, Locality(국부성)에 더 일치할 수 있기 때문에 기억장치 효율이 높아진다.
- 페이지 정보를 갖는 페이지 맵 테이블의 크기가 커지고, 매핑 속도가 늦어진다.
- 디스크 접근 횟수가 많아져서 전체적인 입·출력 시간은 늘어난다.
- 주기억장치에 적재되는 프로그램의 수가 증가된다.
### 페이지 크기가 클 경우
- 페이지 정보를 갖는 페이지 맵 테이블의 크기가 작아지고, 매핑 속도가 빨라진다.
- 디스크 접근 횟수가 줄어들어 전체적인 입·출력의 효율성이 증가된다.
- 페이지 단편화가 증가되고, 한 개의 페이지를 주기억장치로 이동하는 시간이 늘어난다.
- 프로세스(프로그램) 수행에 불필요한 내용까지도 주기억장치에 적재될 수 있다.
- 주기억장치에 적재되는 프로그램의 수가 감소한다.

## 2. Locality (국부성, 지역성, 구역성, 국소성)
프로세스가 실행되는 동안 주기억장치를 참조할 때 ``일부페이지만 집중적으로 참조되는 성질이 있다는 이론``이다.
- 스레싱을 방지하기 위한 **워킹 셋 이론의 기반**이 되었다.
- 프로세스가 집중적으로 사용하는 페이지를 알아내는 방법 중 하나로, 가상기억장치 관리의 이론적인 근거가 된다.
- Denning 교수에 의해 구역성의 개념이 증명되었으며 캐시 메모리 시스템의 이론적 근거이다.

### Locality의 종류
> 시간 구역성(Temporal Locality)
- 프로세스가 실행되면서 하나의 페이지를 ``일정 시간동안 집중적``으로 액세스하는 현상.
- 한 번 참조한 페이지는 가까운 시간 내에 계속 참조할 가능성이 높음을 의미한다.
- 이루어지는 기억 장소 : Loop(반복, 순환), 스택(Stack), 부 프로그램(Sub Routine), Counting(1씩 증감), 집계 (Totaling)에 사용되는 변수(기억장소)
> 공간 구역성(Spatial Locality)
- 프로세스 실행 시 ``일정 위치의 페이지를 집중적으로 액세스``하는 현상.
- 어느 하나의 페이지를 참조하면 그 근처의 페이지를 계속 참조할 가능성이 높음을 의미한다.
- 이루어지는 기억 장소 : 배열 순회(Array Traversal, 배열 순례), 순차적 코드의 실행, 프로그래머들이 관련된 변수(데이터를 기억할 저장장소)들을 서로 근처에 선언하여 할당되는 기억장소, 같은 영역에 있는 변수를 참조할 때 사용.

## 3. 워킹 셋 (Working Set)
프로세스가 일정 시간동안 ``자주 참조하는 페이지들의 집합``.
- Denning이 제안한 것으로, 프로그램의 Locality 특징을 이용한다.
- 자주 참조되는 워킹 셋을 주기억장치에 상주시킴으로써 페이지 부재 및 페이지 교체 현상을 줄인다.
- 주기억장치에는 최소한의 워킹 셋을 올려놓아야 한다.
- 주기억장치 내의 워킹 셋을 감소시키면 주기억장치의 페이지 프레임 공간을 적게 차지하면서 워킹 셋을 사용할 수 있으므로 스래싱이 감소된다.
- 윈도우의 크기, 즉 워킹 셋의 설정 시간 간격이 증가하면 주기억장치에 유지되는 워킹 셋은 커지고, 설정 시간 간격이 감소하면 워킹 셋은 작아진다.
- 워킹 셋으로 인한 오버헤드가 발생될 수 있다.

## 4. 페이지 부재(Page Fault) 빈도(Frequency) 방식
프로세스 실행 시 참조할 펟이지가 주기억장치에 없는 현상. PFF(Page Fault Frequency)는 PF이 일어나는 횟수를 의미한다.
- PFF 방식은 PF에 따라 주기억장치에 있는 **페이지 프레임 수를 늘리거나 줄여** PF을 적정 수준으로 유지하는 방식이다.
- 운영체제는 프로세스 실행 초기에 임의의 페이지 프레임을 할당하고, 페이지 부재율을 지속적으로 감시하고 있다가 부재율이 상한선을 넘어가면 좀 더 많은 프레임을 할당하고, 부재율이 하한선을 넘어가면 페이지 프레임을 회수하는 방식을 사용한다.

## 5. 프리페이징(Prepaging)
처음의 과도한 페이지 부재를 방지하기 위해 **필요할 것 같은 모든 페이지를 한꺼번에 페이지 프레임에 적재하는 기법.**
기억장치에 들어온 페이지들 중에서 사용되지 않는 페이지가 많을 수도 있다.

## 6. 스래싱(Thrashing)
프로세스의 처리 시간보다 페이지 교체 시간이 더 많아지는 현상.
- 다중 프로그래밍 시스템이나 가장 기억장치를 사용하는 시스템에서 하나의 프로세스 수행 과정중 자꾸 페이지 부재가 발생함에 따라 나타나는 현상. 전체 시스템의 성능이 저하된다.
- 다중 프로그래밍의 정도가 높아짐에 따라 CPU의 이용률은 어느 특정 시점까지는 높아지지만, 다중 프로그래밍의 정도가 더욱 커지면 스래싱이 나타나고, PCU의 이용률은 급격히 감소하게 된다.
- CPU 이용률을 높이고 스레싱 현상을 방지하려면, 다중 프로그래밍의 정도를 적정 수준으로 유지하고 페이지 부재 빈도(Page Fault Frequency)를 조절해서 사용하며, Working Set을 유지해야 한다.


# #088. 디스크 스케줄링
자기 디스크, 광 디스크, 자기 테이프 등이 있으나 일반적으로 자기 디스크를 가장 많이 사용한다.

## 1. 디스크 스케줄링(Disk Scheduling)의 개요
사용할 데이터가 디스크 상의 여러 곳에 저장되어 있을 경우 데이터를 액세스하기 위해 디스크 헤드가 움직이는 경로를 설정하는 기법.
- 일반적으로 탐색 시간을 최적화하기 위해 수행된다.

> 처리량 최대화
일정 시간에 디스크 입·출력 요구를 서비스해 주는 수를 최대화한다.
> 응답 시간의 최소화
어떤 요청이 있은 후 결과가 나올 때까지 걸리는 시간을 최소화한다.
> 응답 시간 편차의 최소화
각 요청의 응답 시간과 평균 응답 시간의 편차를 최소화한다.

* 탐색 시간 - 헤드가 지정된 트랙에 도달하는 데 걸리는 시간.
* 회전 시간 - 헤드가 지정된 트랙을 찾은 후 디스크가 회전하여 원하는 섹ㅌ터에서 읽기/쓰기가 시작될 때까지 걸리는 시간.

## 2. FCFS(First Come First Service) = FIFO(First In First Out)
가장 간단한 스케줄링으로, 디스크 대기 큐에 가장 먼저 들어온 트랙에 대한 요청을 먼저 서비스하는 기법.
- 디스크 대기 큐에 있는 트랙 순서대로 디스크 헤드를 이동시킨다.
- 디스크 대기 큐에 들어온 순서대로 서비스하기 때문에 더 높은 우선순위의 요청이 입력되어도 순서가 바뀌지 않아 공평성이 보장된다.
- 디스크 오버헤드가 적을 때 효율적이며, 프로그래밍이 쉽다.
- 헤드 이동 거리가 상당히 길어질 수 있다.
- 디스크 오버헤드가 커지면 응답 시간이 길어진다.
- 탐색 시간을 최적화하려는 시도가 없는 기법이다.

## 3. SSTF(Shortest Seek Time First)
탐색 거리(Seek Distance)가 가장 짧은 트랙에 대한 요청을 먼저 서비스하는 기법.
- 현재 헤드 위치에서 가장 가까운 거리에 있는 트랙으로 헤드를 이동시킨다.
- FCFS보다 처리량이 많고, 평균 탐색 시간이 짧다.
- 처리량이 많은 일괄 처리 시스템에 유용하다.
- 현재 서비스한 트랙에서 가장 가까운 트랙에 대한 서비스 요청이 계속 발생하는 경우, 먼 거리의 트랙(안쪽이나 바깥쪽)에 대한 서비스는 무한정 기다려야 하는 기아상태가 발생할 수 있다.
- 응답 시간의 편차가 크기 때문에 대화형 시스템에는 부적합하다.

## 4. SCAN
SCAN은 SSTF가 갖는 탐색 시간의 편차를 해소하기 위한 기법.
- Denning이 개발한 것으로, 대부분의 디스크 스케줄링에서 ㅣ본 전략으로 이용된다.
- 현재 헤드의 위치에서 진행 방향이 결정되면 탐색 거리가 짧은 순서에 따라 그 방향의 모든 요청을 서비스하고, 끝까지 이동한 후 역방향의 요청 사항을 서비스한다.
- 헤드가 안쪽과 바깥쪽을 왔다갔다 하면서 지나는 길에 있는 대기 요청뿐만 아니라 새로운 요청도 서비스하며, 현재의 진행 방향에 더 이상의 요청이 없을 때에만 이동 방향을 바꾼다.
- SSTF에서 발생하는 응답 시간의 편차를 줄일 수 있다.
- 오버헤드가 적을 경우 가장 효율적인 기법이다.

## 5. C-SCAN(Circular SCAN)
C-SCAN은 항상 바깥쪽에서 안쪽으로 움직이면서 가장 짧은 탐색 거리를 갖는 요청을 서비스하는 기법이다.
- 헤드는 트랙의 바깥쪽에서 안쪽으로 한 방향으로만 움직이며 서비스하여 끝까지 이동한 후, 안쪽에 더 이상의 요청이 없으면 헤드는 가장 바깥쪽의 끝으로 이동한 후 다시 안쪽으로 이동하면서 요첯ㅇ을 서비스한다.
- 마치 처음과 마지막 트랙(Track)을 인접시킨 것과 같은 원형 형태로 Disk를 처리한다.
- 요청을 서비스하는 도중 새로운 요청 사항이 도착하면 다음 헤드가 진행할 때 서비스한다. 트랙의 안족과 바깥쪽의 요청에 대한 서비스가 공평하다.

## 6. N-step SCAN
SCAN 기법을 기초로 하며 어떤 방향의 진행이 시작될 당시에 대기중이던 요청들만 서비스하고, 진행 도중 도착한 요청들은 한데 모아서 다음의 반대 방향 진행 때 서비스하는 기법이다.
- SSTF나 SCAN 기법보다 응답 시간의 편차가 적다.
- 특정 방향에 많은 수의 요청이 도착할 경우 반대 방향에서의 무한 지연 발생을 방지 할 수 있다.
- 진행 도중 도착한 요청은 반대 방향 진행 시 서비스하기 위해 디스크 대기 큐에 저장한다.

## 7. 에센바흐(Eschenbach) 기법
부하가 매우 큰 항공 예약 시스템을 위해 개발된 기법.
탐색 시간과 회전 지연 시간을 최적화하기 위한 최초의 기법이다.

## 8. SLTF(Shortest Latency Time First)
섹터 큐잉(Sector Queuing)라고 하며, 회전 시간의 최적화를 위해 구현된 기법이다.
- 디스크 대기 큐에 있는 여러 요청을 섹터 위치에 다라 재정렬하고, 가장 가까운 섹터를 먼저 서비스한다.
- 헤드의 이동이 거의 없는 고정 헤드 장치인 드럼과 같은 장치에서 사용된다.